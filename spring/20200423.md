# JPA, N+1문제는 언제 발생하는가?



1:N의 관계로 회원 -> 주문의 관계가 있다고 가정하면,



## 첫 번째 케이스

fetch = FetchType.EAGER 로 fetch 옵션을 즉시 로딩으로 가져올 경우 발생

해결책: FetchType을 Lazy로 변경하면 해결



## 두 번째 케이스

fetch = FetchType.LAZY일 경우, 모든 회원을 조회 `findAll()`하는 경우 발생

해결책: batchSize를 설정하여 해결합니다. batchSize는 in절에 파라미터를 설정할 수 있는 개수입니다.

예)

```java
@BatchSize(5)
@ManyToOne(fetch = FetchType.LAZY)
private Order order;
```

새로운 문제: 쿼리문의 in절에 해당하는 값의 글로벌 값이 설정됩니다.

### 새로운 해결책

패치조인 사용

- 용어는 패치조인인데, join fetch임.

- 패치조인을 사용하면 프록시 객체가 아니라 실제 엔티티를 조회하고, 연관된 객체를 모두 조회 함.

- 패치조인을 사용하면, 페이징 쿼리를 사용할 수 없다. 왜냐하면 회원 10개에 해당하는 주문 100개를 조회한다고 가정하면 사용자는 회원 10개에 대한 페이징을 원하지만 데이터는 주문 100개를 갖고 페이징쿼리 내부의 count(*)에 사용한다. 또한 데이터베이스를 Full Scan하므로 성능 이슈도 있다.

- List를 Set으로 바꾸면 해결된다고 하는데 해보진 않았으며 이러한 해결법은 근본적인게 아닌 꼼수이므로 권장하지 않는다.


